// willslib.c -- created by Will Sussman on December 26, 2019

#define _GNU_SOURCE

#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <unistd.h>
#include <fcntl.h>
#include "willslib.h"

int loadTop(FILE *stream, struct Topdata *topdata){
	topdata->list = NULL;
	topdata->hosts = NULL;
	topdata->nhosts = 0;
	char *line = NULL;
	size_t size = 0;
	while(getline(&line,&size,stream) != EOF){
		parseLine(line,topdata);
		free(line);
		line = NULL;
		size = 0;
	}
	free(line);
	topdata->hostSocks = malloc(sizeof(*topdata->hostSocks) * topdata->nhosts);
	if(!topdata->hostSocks){
		fprintf(stderr,"loadTop(): malloc() failed\n");
		return 1;
	}
	return 0;
}

int printTop(FILE *stream, struct Line *datalist){
	struct Line *currlinePtr = datalist;
	while(currlinePtr){
		if(currlinePtr->set){
			printLine(stream,currlinePtr);
		}
		currlinePtr = currlinePtr->next;
	}
	return 0;
}

int freeTop(struct Topdata topdata){
	struct Line *currlinePtr = topdata.list, *nextlinePtr;
	while(currlinePtr){
		nextlinePtr = currlinePtr->next;
		freeLine(currlinePtr);
		currlinePtr = nextlinePtr;
	}
	struct Host *currhostPtr = topdata.hosts, *nexthostPtr;
	while(currhostPtr){
		nexthostPtr = currhostPtr->next;
		free(currhostPtr->addr);
		free(currhostPtr);
		currhostPtr = nexthostPtr;
	}
	return 0;
}

int topAdd(struct Line **topdata, struct Line *linePtr){
	if(!*topdata){
		*topdata = linePtr;
		linePtr->next = NULL;
		return 0;
	}
	struct Line *currlinePtr = *topdata, *prevlinePtr = NULL;
	while(linePtr->idnum > currlinePtr->idnum){
		prevlinePtr = currlinePtr;
		if(!(currlinePtr = currlinePtr->next)){
			break;
		}
	}
	if(prevlinePtr){
		prevlinePtr->next = linePtr;
	} else {
		*topdata = linePtr;
	}
	linePtr->next = currlinePtr;
	return 0;
}

int topDelete(struct Line **topdata, struct Line *linePtr){
	if(!*topdata){
		fprintf(stderr,"topDelete(): cannot delete from empty topdata\n");
		return 1;
	}
	struct Line *currlinePtr = *topdata, *prevlinePtr = NULL;
	while(linePtr->idnum != currlinePtr->idnum){
		prevlinePtr = currlinePtr;
		if(!(currlinePtr = currlinePtr->next)){
			fprintf(stderr,"topDelete(): cannot delete nonexistent line\n");
			return 1;
		}
	}
	if(prevlinePtr){
		prevlinePtr->next = currlinePtr->next;
	}
	freeLine(currlinePtr);
	return 0;
}

int topInsert(struct Line **topdata, struct Line *linePtr){
	if(!*topdata){
		*topdata = linePtr;
		linePtr->next = NULL;
		return 0;
	}
	struct Line *currlinePtr = *topdata, *prevlinePtr = NULL;
	char dir;
	while(linePtr->idnum > currlinePtr->idnum){
		if(isNeighbor(currlinePtr->idnum,linePtr->neighbors,&dir)){
			addNeighbor(linePtr,&currlinePtr->neighbors,oppDir(dir));
		}
		prevlinePtr = currlinePtr;
		if(!(currlinePtr = currlinePtr->next)){
			break;
		}
	}
	if(prevlinePtr){
		prevlinePtr->next = linePtr;
	}
	linePtr->next = currlinePtr;
	while(currlinePtr){
		if(isNeighbor(currlinePtr->idnum,linePtr->neighbors,&dir)){
			addNeighbor(linePtr,&currlinePtr->neighbors,oppDir(dir));
		}
		currlinePtr = currlinePtr->next;
	}
	return 0;
}

int topRemove(struct Line **topdata, struct Line *linePtr){
	if(!*topdata){
		fprintf(stderr,"topRemove(): cannot remove from empty topdata\n");
		return 1;
	}
	struct Line *currlinePtr = *topdata, *prevlinePtr = NULL;
	while(linePtr->idnum != currlinePtr->idnum){
		if(isNeighbor(currlinePtr->idnum,linePtr->neighbors,NULL)){
			deleteNeighbor(linePtr->idnum,&currlinePtr->neighbors);
		}
		prevlinePtr = currlinePtr;
		if(!(currlinePtr = currlinePtr->next)){
			fprintf(stderr,"topRemove(): cannot remove nonexistent line\n");
			return 1;
		}
	}
	if(prevlinePtr){
		prevlinePtr->next = currlinePtr->next;
	}
	prevlinePtr = currlinePtr;
	while(currlinePtr){
		if(isNeighbor(currlinePtr->idnum,linePtr->neighbors,NULL)){
			deleteNeighbor(linePtr->idnum,&currlinePtr->neighbors);
		}
	}
	freeLine(prevlinePtr);
	return 0;
}

int parseLine(char *line, struct Topdata *topdata){
	int idnum = atoi(line);
	struct Line *linePtr = lineLookup(topdata->list,idnum), *neighborLine;
	bool newblock = !linePtr;
	if(newblock){
		linePtr = malloc(sizeof(*linePtr));
		if(!linePtr){
			fprintf(stderr,"parseLine(): malloc() failed\n");
			return 1;
		}
		linePtr->idnum = idnum;
	}

	int i = 0;
	while(line[i++] != '\t');
	int j = i;
	while(line[j++] != '\t');
	// linePtr->host->addr = malloc(sizeof(*linePtr->host->addr) * (j - i));
	// strncpy(linePtr->host->addr,line + i,j - i - 1);
	// linePtr->host->addr[j-i-1] = '\0';

	bool newhost = true;
	struct Host *currhostPtr = topdata->hosts, *prevhostPtr = NULL;
	while(currhostPtr){
		if(!strncmp(line + i,currhostPtr->addr,j - i - 1)){
			newhost = false;
			linePtr->host = currhostPtr;
			break;
		}
		prevhostPtr = currhostPtr;
		currhostPtr = currhostPtr->next;
	}
	if(newhost){
		topdata->nhosts++;
		// topdata->hosts = realloc(topdata->hosts,sizeof(*topdata->hosts) * ++topdata->nhosts);
		// linePtr->host = &topdata->hosts[topdata->nhosts - 1];
		// printf("newhost\n");
		struct Host *newhostPtr = malloc(sizeof(*newhostPtr));

		newhostPtr->addr = malloc(sizeof(*linePtr->host->addr) * (j - i));
		strncpy(newhostPtr->addr,line + i,j - i - 1);
		newhostPtr->addr[j-i-1] = '\0';

		linePtr->host = newhostPtr;

		// if(currhostPtr){
		// 	printf("curr is %s\n",currhostPtr->addr);
		// } else {
		// 	printf("curr is null\n");
		// }
		if(prevhostPtr){
			// printf("prev is %s\n",prevhostPtr->addr);
			prevhostPtr->next = newhostPtr;
		} else {
			// printf("prev is null\n");
			topdata->hosts = newhostPtr;
		}
		newhostPtr->next = currhostPtr;


		// printf("NOW:\n");
		// if(prevhostPtr){
		// 	printf("prev is %s\n",prevhostPtr->addr);
		// } else {
		// 	printf("prev is null\n");
		// }
		// printf("new is %s\n",newhostPtr->addr);
		// if(currhostPtr){
		// 	printf("curr is %s\n",currhostPtr->addr);
		// } else {
		// 	printf("curr is null\n");
		// }
		// struct Host *ptr = topdata->hosts;
		// while(ptr){
		// 	printf("currblock is %s\n",ptr->addr);
		// 	if(!ptr->next){
		// 		printf("nextblock is null\n");
		// 	}
		// 	ptr = ptr->next;
		// }
	}

	// currhostPtr = topdata->hosts;
	// int n = 1;
	// while(currhostPtr){
	// 	printf("host %d: %s\n",n++,currhostPtr->addr);
	// }

	linePtr->seen = false;
	linePtr->used = false;
	linePtr->queried = false;
	linePtr->triplet[0] = '-';
	linePtr->triplet[1] = '-';
	linePtr->triplet[2] = '0';

	i = j;
	while(line[i++] != '\t');
	linePtr->ipaddr = malloc(sizeof(*linePtr->ipaddr) * (i - j));
	strncpy(linePtr->ipaddr,line + j,i - j - 1);
	linePtr->ipaddr[i-j-1] = '\0';

	j = i;
	while(line[i++] != '\t');
	linePtr->ants.num = i - j - 1;
	linePtr->ants.array = malloc(sizeof(*linePtr->ants.array) * linePtr->ants.num);
	strncpy(linePtr->ants.array,line + j,linePtr->ants.num);

	j = i;
	while(line[i++] != '\t');
	linePtr->neighbors.count = i - j - 1;
	// printf("count is: %d\n",linePtr->neighbors.count);
	linePtr->neighbors.idnums = malloc(sizeof(*linePtr->neighbors.idnums) * linePtr->neighbors.count);
	linePtr->neighbors.dirs = malloc(sizeof(*linePtr->neighbors.dirs) * linePtr->neighbors.count);
	linePtr->neighbors.lines = malloc(sizeof(*linePtr->neighbors.lines) * linePtr->neighbors.count);
	strncpy(linePtr->neighbors.dirs,line + j,linePtr->neighbors.count);

	// int numCommas = 0;
	// for(j = i; line[j] != '\t'; j++){
	// 	if(line[j] == ','){
	// 		numCommas++;
	// 	}
	// }

	// if(j == i){
	// 	linePtr->neighbors.count = 0;
	// 	linePtr->neighbors.idnums = NULL;
	// 	linePtr->neighbors.lines = NULL;
	// 	linePtr->neighbors.dirs = NULL;
	// 	linePtr->set = true;
	// 	if(newblock){
	// 		topAdd(&topdata->list,linePtr);
	// 	}
	// 	return 0;
	// }

	// linePtr->neighbors.count = numCommas + 1;
	// linePtr->neighbors.idnums = malloc(sizeof(*linePtr->neighbors.idnums) * linePtr->neighbors.count);
	// linePtr->neighbors.dirs = malloc(sizeof(*linePtr->neighbors.dirs) * linePtr->neighbors.count);
	// linePtr->neighbors.lines = malloc(sizeof(*linePtr->neighbors.lines) * linePtr->neighbors.count);
	char *ptr = line + i - 1;
	// j--;
	for(i = 0; i < linePtr->neighbors.count; i++){
		linePtr->neighbors.idnums[i] = strtol(ptr + 1,&ptr,10); // Neat trick!
		// linePtr->neighbors.dirs[i] = line[j += 2];

		neighborLine = lineLookup(topdata->list,linePtr->neighbors.idnums[i]);
		if(neighborLine){
			linePtr->neighbors.lines[i] = neighborLine;
		} else {
			linePtr->neighbors.lines[i] = malloc(sizeof(*linePtr->neighbors.lines[i]));
			linePtr->neighbors.lines[i]->idnum = linePtr->neighbors.idnums[i];
			linePtr->neighbors.lines[i]->set = false;
			topAdd(&topdata->list,linePtr->neighbors.lines[i]);
		}

	}
	linePtr->set = true;
	if(newblock){
		topAdd(&topdata->list,linePtr);
	}
	return 0;
}

int printLine(FILE *stream, struct Line *linePtr){

	fprintf(stream,"%d\t%s\t%s\t",linePtr->idnum,linePtr->host->addr,linePtr->ipaddr);

	for(int i = 0; i < linePtr->ants.num; i++){
		fprintf(stream,"%c",linePtr->ants.array[i]);
	}
	fprintf(stream,"\t");

	if(linePtr->neighbors.count == 0){
		fprintf(stream,"\t\n");
		return 0;
	}

	for(int i = 0; i < linePtr->neighbors.count; i++){
		fprintf(stream,"%c",linePtr->neighbors.dirs[i]);
	}
	fprintf(stream,"\t");

	for(int i = 0; i < linePtr->neighbors.count - 1; i++){
		fprintf(stream,"%d,",linePtr->neighbors.idnums[i]);
	}
	fprintf(stream,"%d\n",linePtr->neighbors.idnums[linePtr->neighbors.count - 1]);
	return 0;
}

/*
struct Line {
	int idnum; // ID number of the node
	struct Host *host; // pointer to the Host that controls the node
	char *ipaddr; // IP address of the node
	struct Neighbors neighbors; // neighbors of the node
	struct Line *next; // pointer to next node in linked list
	bool seen; // used for path generation; whether the node is already in the path
	bool used; // used for path generation; whether the node is already in a chosen path
	bool set; // used for data structure initialization; whether the block has been initialized
	int sock; // socket of the node
	char triplet[3]; // used for sending commands; holds the 3-byte command
	float voltage;
	float powerIndex;
	struct Antennas ants;
};
*/

int freeLine(struct Line *linePtr){
	// free(linePtr->host->addr);
	free(linePtr->ipaddr);
	free(linePtr->neighbors.idnums);
	free(linePtr->neighbors.dirs);
	free(linePtr->neighbors.lines);
	// free(linePtr->triplet);
	free(linePtr->ants.array);
	free(linePtr);
	return 0;
}

int isNeighbor(int idnum, struct Neighbors neighbors, char *dir){
	for(int i = 0; i < neighbors.count; i++){
		if(neighbors.idnums[i] == idnum){
			if(dir != NULL){
				*dir = neighbors.dirs[i];
			}
			return 1;
		}
	}
	return 0;
}

int addNeighbor(struct Line *linePtr, struct Neighbors *neighborsPtr, char dir){
	int *newIdnums = malloc(sizeof(*newIdnums) * (neighborsPtr->count + 1));
	struct Line **newLines = malloc(sizeof(*newLines) * (neighborsPtr->count + 1));
	char *newDirs = malloc(sizeof(*newDirs) * (neighborsPtr->count + 1));
	int i;
	for(i = 0; i < neighborsPtr->count; i++){
		if(neighborsPtr->idnums[i] > linePtr->idnum){
			break;
		}
		newIdnums[i] = neighborsPtr->idnums[i];
		newLines[i] = neighborsPtr->lines[i];
		newDirs[i] = neighborsPtr->dirs[i];
	}
	newIdnums[i] = linePtr->idnum;
	newLines[i] = linePtr;
	newDirs[i] = dir;
	while(i < neighborsPtr->count){
		newIdnums[i+1] = neighborsPtr->idnums[i];
		newLines[i+1] = neighborsPtr->lines[i];
		newDirs[i+1] = neighborsPtr->dirs[i];
		i++;
	}
	neighborsPtr->count++;
	free(neighborsPtr->idnums);
	neighborsPtr->idnums = newIdnums;
	free(neighborsPtr->lines);
	neighborsPtr->lines = newLines;
	free(neighborsPtr->dirs);
	neighborsPtr->dirs = newDirs;
	return 0;
}

int deleteNeighbor(int idnum, struct Neighbors *neighborsPtr){
	int *newIdnums = malloc(sizeof(*newIdnums) * (neighborsPtr->count - 1));
	struct Line **newLines = malloc(sizeof(*newLines) * (neighborsPtr->count - 1));
	char *newDirs = malloc(sizeof(*newDirs) * (neighborsPtr->count - 1));
	int i;
	for(i = 0; i < neighborsPtr->count; i++){
		if(neighborsPtr->idnums[i] == idnum){
			break;
		}
		newIdnums[i] = neighborsPtr->idnums[i];
		newLines[i] = neighborsPtr->lines[i];
		newDirs[i] = neighborsPtr->dirs[i];
	}
	while(i < neighborsPtr->count){
		newIdnums[i] = neighborsPtr->idnums[i+1];
		newLines[i] = neighborsPtr->lines[i+1];
		newDirs[i] = neighborsPtr->dirs[i+1];
		i++;
	}
	neighborsPtr->count--;
	free(neighborsPtr->idnums);
	neighborsPtr->idnums = newIdnums;
	free(neighborsPtr->lines);
	neighborsPtr->lines = newLines;
	free(neighborsPtr->dirs);
	neighborsPtr->dirs = newDirs;
	return 0;
}

char oppDir(char dir){
	if(dir == 'n'){
		return 's';
	} else if(dir == 'e'){
		return 'w';
	} else if(dir == 's'){
		return 'n';
	} else if(dir == 'w'){
		return 'e';
	} else {
		fprintf(stderr,"oppDir(): invalid direction, defaulting to '-'\n");
		return '-';
	}
}

struct Line *lineLookup(struct Line *datalist, int idnum){
	struct Line *currlinePtr = datalist;
	while(currlinePtr && idnum != currlinePtr->idnum){
		currlinePtr = currlinePtr->next;
	}
	return currlinePtr;
}

int genPaths(struct Paths *allpaths, struct Line *datalist, int startid, int endid, bool disjoint){
	struct Line *startline = lineLookup(datalist,startid);
	if(!startline){
		fprintf(stderr,"genPaths(): startid does not exist\n");
		return 1;
	}
	
	struct Path path;
	path.len = 0;
	path.nodes = NULL;
	struct Paths pathset;
	pathset.count = 0;
	pathset.paths = NULL;

	genPathsAux(startline,&path,&pathset,endid,disjoint);
	*allpaths = pathset;
	return 0;
}

int genPathsAux(struct Line *currlinePtr, struct Path *path, struct Paths *pathset, int endid, bool disjoint){
	pathPush(path,currlinePtr);
	if(currlinePtr->idnum == endid){
		savePath(path,pathset);
		pathPop(path);
		return 0;
	}
	currlinePtr->seen = true;
	for(int i = 0; i < currlinePtr->neighbors.count; i++){
		if(!currlinePtr->neighbors.lines[i]->seen && (disjoint ? !currlinePtr->neighbors.lines[i]->used : true)){
			genPathsAux(currlinePtr->neighbors.lines[i],path,pathset,endid,disjoint);
		}
	}
	pathPop(path);
	currlinePtr->seen = false;
	return 0;
}

/*
int openAllComms(struct Line *topdata, int port, float timeout){
	struct Line *currlinePtr = topdata;
	// struct sockaddr_in server;
	// server.sin_family = AF_INET;
	// server.sin_port = htons(port);
	// int nfds;
	// fd_set fdset;
	// struct timeval tv;
	// long long usecs = timeout * 1000000;
	// tv.tv_sec = usecs / 1000000;
	// tv.tv_usec = usecs % 1000000;
	// int optval;
	// socklen_t optlen = sizeof(optval);
	while(currlinePtr){
		if((currlinePtr->sock = openComms(currlinePtr->ipaddr,port,timeout)) == -1){
			fprintf(stderr,"openAllComms(): openComms() failed for %s\n",currlinePtr->ipaddr);
			return 1;
		}
		// if((currlinePtr->sock = socket(AF_INET,SOCK_STREAM,0)) == -1){
		// 	fprintf(stderr,"openAllComms(): socket() failed at line %d\n",currlinePtr->idnum);
		// 	return 1;
		// }
		// if(fcntl(currlinePtr->sock,F_SETFL,O_NONBLOCK) == -1){
		// 	fprintf(stderr,"openAllComms(): fcntl() failed at line %d\n",currlinePtr->idnum);
		// 	return 1;
		// }
		// server.sin_addr.s_addr = inet_addr(currlinePtr->ipaddr);
		// // if(inet_pton(AF_INET,currlinePtr->ipaddr,&server.sin_addr) != 1){
		// // 	fprintf(stderr,"openAllComms(): inet_pton() failed at line %d\n",currlinePtr->idnum);
		// // 	return 1;
		// // }
		// if(connect(currlinePtr->sock,(struct sockaddr *)&server,sizeof(server))){
		// 	// perror(currlinePtr->ipaddr);
		// 	// fprintf(stderr,"openAllComms(): connect() failed for %s\n",currlinePtr->ipaddr);
		// 	// return 1;
		// }
		// FD_ZERO(&fdset);
	 //    FD_SET(currlinePtr->sock,&fdset);
	 //    if((nfds = select(currlinePtr->sock + 1,NULL,&fdset,NULL,&tv)) == -1){
	 //    	fprintf(stderr,"openAllComms(): select() failed at line %d\n",currlinePtr->idnum);
	 //    	return 1;
	 //    } else if(nfds == 0){
	 //    	fprintf(stderr,"openAllComms(): timeout expired for %s\n",currlinePtr->ipaddr);
	 //    	return 1;
	 //    } else {
	 //        if(getsockopt(currlinePtr->sock,SOL_SOCKET,SO_ERROR,&optval,&optlen) == -1){
	 //        	fprintf(stderr,"openAllComms(): getsockopt() failed at line %d\n",currlinePtr->idnum);
	 //        	return 1;
	 //        }
	 //        if(!optval) {
	 //        	fprintf(stdout,"openAllComms(): %s is open\n",currlinePtr->ipaddr);
	 //        }
	 //    }
		currlinePtr = currlinePtr->next;
	}
	return 0;
}
*/

/*
int closeAllComms(struct Line *topdata){
	struct Line *currlinePtr = topdata;
	while(currlinePtr){
		if(close(currlinePtr->sock)){
			perror(currlinePtr->ipaddr);
			// fprintf(stderr,"closeAllComms(): close() failed at line %d\n",currlinePtr->idnum);
			// return 1;
		} else {
			fprintf(stdout,"closeAllComms(): %s is closed\n",currlinePtr->ipaddr);
		}
		currlinePtr = currlinePtr->next;
	}
	return 0;
}
*/

int prepCmds(struct Line *datalist, char startdir, struct Path path, char enddir){
	if(path.len == 0){
		fprintf(stderr,"prepCmds(): path must have at least 1 node\n");
		return 1;
	}

	// path.nodes[0]->triplet = malloc(sizeof(*path.nodes[0]->triplet) * 3);
	path.nodes[0]->triplet[0] = startdir;
	for(int i = 0; i < path.len - 1; i++){
		isNeighbor(path.nodes[i+1]->idnum,path.nodes[i]->neighbors,&path.nodes[i]->triplet[1]);
		path.nodes[i]->triplet[2] = '0';
		// path.nodes[i+1]->triplet = malloc(sizeof(*path.nodes[i+1]->triplet) * 3);
		isNeighbor(path.nodes[i]->idnum,path.nodes[i+1]->neighbors,&path.nodes[i+1]->triplet[0]);
	}
	path.nodes[path.len - 1]->triplet[1] = enddir;
	path.nodes[path.len - 1]->triplet[2] = '0';

	return 0;
}

int prepOffCmds(struct Line *datalist){
	// char *triplet;
	while(datalist){
		// datalist->triplet = malloc(sizeof(*triplet) * 3);
		datalist->triplet[0] = '-';
		datalist->triplet[1] = '-';
		datalist->triplet[2] = '0';
		datalist = datalist->next;
	}
	return 0;
}

int setQuad(char *quad, char first, char second, char third, char fourth){
	quad[0] = first; quad[1] = second; quad[2] = third; quad[3] = fourth;
	return 0;
}

int prepGivenCmds(struct Line *datalist, char *request){
	while(datalist){
		datalist->triplet[0] = request[0];
		datalist->triplet[1] = request[1];
		datalist->triplet[2] = request[2];
		datalist = datalist->next;
	}
	return 0;
}

int sendAllCmds(struct Line *listPtr){
	while(listPtr){
		// if(write(listPtr->host->sock,&listPtr->idnum,1) == -1){
		// 	fprintf(stderr,"sendAllCmds(): write() failed for %s\n",listPtr->host->addr);
		// 	return 1;
		// }
		// printf("Sending (%d:%c%c%c) to %s\n",listPtr->idnum,listPtr->triplet[0],listPtr->triplet[1],listPtr->triplet[2],listPtr->host->addr);
		if(sendQuad(listPtr->host->sock,listPtr->idnum,listPtr->triplet)){
			fprintf(stderr,"sendAllCmds(): sendQuad() failed for %s\n",listPtr->host->addr);
			return 1;
		}

		if(listPtr->triplet){
			listPtr->triplet[0] = '-';
			listPtr->triplet[1] = '-';
			listPtr->triplet[2] = '0';
		}

		listPtr = listPtr->next;
	}
	return 0;
}

int reopenServ(int listenSock, struct sockaddr_in *server){
	if(listen(listenSock,1)){
		fprintf(stderr,"reopenServ(): listen() failed\n");
		return -1;
	}

	struct sockaddr_in client;
	unsigned int len = sizeof(client), recSock;
	if((recSock = accept(listenSock,(struct sockaddr *)server,&len)) == -1){
		fprintf(stderr,"reopenServ(): accept() failed\n");
		return -1;
	}

	return recSock;
}

int openServ(int *listenSock, int port, float timeout, struct sockaddr_in *server){
	// struct sockaddr_in server;
	if((*listenSock = socket(AF_INET,SOCK_STREAM,0)) == -1){
		fprintf(stderr,"openServ(): socket() failed\n");
		return -1;
	}
	memset(server,0,sizeof(*server));
	server->sin_family = AF_INET;
	server->sin_addr.s_addr = htonl(INADDR_ANY);
	// if(inet_pton(AF_INET,currlinePtr->ipaddr,&server.sin_addr) != 1){
	// 	fprintf(stderr,"openComms(): inet_pton() failed\n");
	// 	return 1;
	// }
	server->sin_port = htons(port);



	// int nfds;
	// fd_set fdset;
	// struct timeval tv;
	// long long usecs = timeout * 1000000;
	// tv.tv_sec = usecs / 1000000;
	// tv.tv_usec = usecs % 1000000;
	// int optval;
	// socklen_t optlen = sizeof(optval);
	// if(fcntl(sock,F_SETFL,O_NONBLOCK) == -1){
	// 	fprintf(stderr,"openComms(): fcntl() failed\n");
	// 	return -1;
	// }

	if(bind(*listenSock,(struct sockaddr *)server,sizeof(*server))){
		perror("openServ()");
		// fprintf(stderr,"openServ(): bind() failed\n");
		return -1;
	}

	if(listen(*listenSock,1)){
		fprintf(stderr,"openServ(): listen() failed\n");
		return -1;
	}
	// if(connect(sock,(struct sockaddr *)&server,sizeof(server))){
	// 	// fprintf(stderr,"openComms(): connect() failed for %s\n",ipaddr);
	// 	// return 1;
	// }

	struct sockaddr_in client;
	unsigned int len = sizeof(client), recSock;
	if((recSock = accept(*listenSock,(struct sockaddr *)server,&len)) == -1){
		fprintf(stderr,"openServ(): accept() failed\n");
		return -1;
	}

	// FD_ZERO(&fdset);
 //    FD_SET(sock,&fdset);
 //    if((nfds = select(sock + 1,NULL,&fdset,NULL,&tv)) == -1){
 //    	fprintf(stderr,"openComms(): select() failed\n");
 //    	return -1;
 //    } else if(nfds == 0){
 //    	fprintf(stderr,"openComms(): timeout expired\n");
 //    	return -1;
 //    } else {
 //        if(getsockopt(sock,SOL_SOCKET,SO_ERROR,&optval,&optlen) == -1){
 //        	fprintf(stderr,"openComms(): getsockopt() failed\n");
 //        	return -1;
 //        }
 //        if(!optval) {
 //        	fprintf(stdout,"openComms(): successfully opened\n");
 //        }
 //    }

	// close(sock);
	return recSock;
}

int openClient(char *ipaddr, int port, float timeout){
	int sock;
	struct sockaddr_in server;
	if((sock = socket(AF_INET,SOCK_STREAM,0)) == -1){
		// fprintf(stderr,"openClient(): socket() failed\n");
		perror("openClient(){socket()}");
		return -1;
	}
	memset(&server,0,sizeof(server));
	server.sin_family = AF_INET;
	// server.sin_addr.s_addr = htonl(INADDR_ANY);
	if(inet_pton(AF_INET,ipaddr,&server.sin_addr) != 1){
		// fprintf(stderr,"openClient(): inet_pton() failed\n");
		perror("openClient{inet_pton()}");
		return -1;
	}
	server.sin_port = htons(port);



	// int nfds;
	// fd_set fdset;
	// struct timeval tv;
	// long long usecs = timeout * 1000000;
	// tv.tv_sec = usecs / 1000000;
	// tv.tv_usec = usecs % 1000000;
	// int optval;
	// socklen_t optlen = sizeof(optval);
	// if(fcntl(sock,F_SETFL,O_NONBLOCK) == -1){
	// 	fprintf(stderr,"openComms(): fcntl() failed\n");
	// 	return -1;
	// }

	// if(bind(sock,(struct sockaddr *)&server,sizeof(server))){
	// 	fprintf(stderr,"openServ(): bind() failed\n");
	// 	return -1;
	// }

	// if(listen(sock,1)){
	// 	fprintf(stderr,"openServ(): listen() failed\n");
	// 	return -1;
	// }

	if(connect(sock,(struct sockaddr *)&server,sizeof(server))){
		perror(ipaddr);
		// fprintf(stderr,"openClient(): connect() failed for %s\n",ipaddr);
		return -1;
	}

	// struct sockaddr_in client;
	// int len = sizeof(client), sockfd;
	// if((sockfd = accept(sock,(struct sockaddr *)&server,&len)) == -1){
	// 	fprintf(stderr,"openServ(): accept() failed\n");
	// 	return -1;
	// }

	// FD_ZERO(&fdset);
 //    FD_SET(sock,&fdset);
 //    if((nfds = select(sock + 1,NULL,&fdset,NULL,&tv)) == -1){
 //    	fprintf(stderr,"openComms(): select() failed\n");
 //    	return -1;
 //    } else if(nfds == 0){
 //    	fprintf(stderr,"openComms(): timeout expired\n");
 //    	return -1;
 //    } else {
 //        if(getsockopt(sock,SOL_SOCKET,SO_ERROR,&optval,&optlen) == -1){
 //        	fprintf(stderr,"openComms(): getsockopt() failed\n");
 //        	return -1;
 //        }
 //        if(!optval) {
 //        	fprintf(stdout,"openComms(): successfully opened\n");
 //        }
 //    }

	return sock; //sockfd?
}

int recCmd(int recSock, struct Cmd *cmd){
	char quad[4];
	int nrec = read(recSock,quad,4);
	if(!nrec){
		return 0;
	} else if(nrec == -1){
		fprintf(stderr,"recCmd(): read() failed\n");
		return -1;
	} else if(nrec != 4){
		fprintf(stderr,"recCmd(): read() failed to fill quad (only got %d/4)\n",nrec);
		return -1;
	} else {
		// printf("About to set cmd->idnum to %d\n",(int)quad[0]);
		// printf("About to set cmd->triplet[0] to %c",quad[1]);
		// printf("About to set cmd->triplet[1] to %c",quad[2]);
		// printf("About to set cmd->triplet[2] to %c",quad[3]);
		cmd->idnum = (int)quad[0];
		cmd->triplet[0] = quad[1];
		cmd->triplet[1] = quad[2];
		cmd->triplet[2] = quad[3];
		return 1;
	}
}

float average(float *vVals, int nTrials){
	float sum = 0;
	for(int i = 0; i < nTrials; i++){
		sum += vVals[i];
	}
	return sum /= nTrials;
}

int queryRecv(int sock, struct Data *data){
	// char request[3] = {dir,'-','v'};
	// if(sendTriplet(sock,request)){
	// 	fprintf(stderr,"queryUnit(): sendTriplet() failed\n");
	// 	return -1;
	// }

	// fprintf(stderr,"About to read\n");
	// printf("sizeof(struct Data) is %ld\n",sizeof(struct Data));
	int nrec = read(sock,data,ARDUINO_SIZEOF_STRUCT_DATA);
	if(!nrec){
		return 0;
	} else if(nrec == -1){
		fprintf(stderr,"queryRecv(): read() failed\n");
		return -1;
	} else if(nrec != ARDUINO_SIZEOF_STRUCT_DATA){
		fprintf(stderr,"queryRecv(): read() failed to fill data (only got %d/%d)\n",nrec,ARDUINO_SIZEOF_STRUCT_DATA);
		return -1;
	}

	return 1;
}

int queryUnit(int sock, char dir, struct Data *data){
	char request[3] = {dir,'-','v'};
	if(sendTriplet(sock,request)){
		fprintf(stderr,"queryUnit(): sendTriplet() failed\n");
		return -1;
	}

	// fprintf(stderr,"About to read\n");
	// printf("sizeof(struct Data) is %ld\n",sizeof(struct Data));
	int nrec = read(sock,data,ARDUINO_SIZEOF_STRUCT_DATA);
	if(!nrec){
		return 0;
	} else if(nrec == -1){
		fprintf(stderr,"queryRecv(): read() failed\n");
		return -1;
	} else if(nrec != ARDUINO_SIZEOF_STRUCT_DATA){
		fprintf(stderr,"queryRecv(): read() failed to fill data (only got %d/%d)\n",nrec,ARDUINO_SIZEOF_STRUCT_DATA);
		return -1;
	}

	return 1;
}

struct Report getMedian(struct Data *dataBlocks, int idnum, int ntrials){
	struct Report median;
	median.idnum = idnum;
	selectionSort(dataBlocks,ntrials);
	median.data = dataBlocks[((ntrials - 1) / 2)];
	return median;
}

void selectionSort(struct Data *dataBlocks, int ntrials){
	struct Data min;
	int iMin;
	// int i;

	// printf("Original:");
	// for(int i = 0; i < ntrials; i++){
	// 	printf(" %f ",dataBlocks[i].val);
	// }
	// printf("\n");

	for(int dest = 0; dest < ntrials - 1; dest++){
		min = dataBlocks[dest];
		iMin = dest;
		for(int i = dest + 1; i < ntrials; i++){
			if(dataBlocks[i].val < min.val){
				min = dataBlocks[i];
				iMin = i;
			}
		}

		dataBlocks[iMin] = dataBlocks[dest];
		dataBlocks[dest] = min;

		// printf("Moving %d to %d, and putting temp in %d\n",iMin,dest,iMin);
		// temp = dataBlocks[dest];
		// dataBlocks[dest] = dataBlocks[iMin];
		// dataBlocks[iMin] = temp;
		// printf("Setting %d to %d, and %d to min\n",iMin,dest,dest);
		// dataBlocks[iMin] = dataBlocks[dest];
		// dataBlocks[dest] = min;

		// printf("List now:");
		// for(int i = 0; i < ntrials; i++){
		// 	printf(" %f ",dataBlocks[i].val);
		// }
		// printf("\n");
	}

	// int dest = 0;
	// struct Data temp;
	// for(int i = 1; i < ntrials; i++){
	// 	if(dataBlocks[i].val < dataBlocks[dest].val){
	// 		printf("Swapping %d and %d\n",i,dest);
	// 		temp = dataBlocks[dest];
	// 		dataBlocks[dest] = dataBlocks[i];
	// 		dataBlocks[i] = temp;
	// 		i = ++dest; // will be incremented by for loop
	// 	}
	// }
	printf("Sorted list:");
	for(int i = 0; i < ntrials; i++){
		printf(" %f ",dataBlocks[i].val);
	}
	printf("\n");
	return;
}

// int queryBestVoltage(int sock, struct Max *vBlock, struct Max *pBlock){
// 	/* Simulation */
// 	vBlock->val = 10;
// 	vBlock->dir = 'n';
// 	pBlock->val = 20;
// 	pBlock->dir = 's';
// 	return 1;

// 	char request[3] = {'-','-','v'};
// 	if(sendTriplet(sock,request)){
// 		fprintf(stderr,"queryVoltage(): sendTriplet() failed\n");
// 		return -1;
// 	}

// 	// fprintf(stderr,"About to read\n");
// 	int nrec = read(sock,vBlock,sizeof(*vBlock));
// 	if(!nrec){
// 		return 0;
// 	} else if(nrec == -1){
// 		fprintf(stderr,"queryVoltage(): read() failed\n");
// 		return -1;
// 	} else if(nrec != sizeof(*vBlock)){
// 		fprintf(stderr,"queryVoltage(): read() failed to fill voltage (only got %d/%ld)\n",nrec,sizeof(*vBlock));
// 		return -1;
// 	}

// 	nrec = read(sock,pBlock,sizeof(*pBlock));
// 	if(!nrec){
// 		return 0;
// 	} else if(nrec == -1){
// 		fprintf(stderr,"queryVoltage(): read() failed\n");
// 		return -1;
// 	} else if(nrec != sizeof(*pBlock)){
// 		fprintf(stderr,"queryVoltage(): read() failed to fill powerIndex (only got %d/%ld)\n",nrec,sizeof(*pBlock));
// 		return -1;
// 	}

// 	return 1;
// }

int getReport(int sock, struct Report *report){
	// char request[3] = {dir,mid,type};
	// if(sendQuad(sock,idnum,request)){
	// 	fprintf(stderr,"getReport(): sendQuad() failed\n");
	// 	return 1;
	// }

	int nrec = read(sock,report,sizeof(*report));
	if(!nrec){
		return 0;
	} else if(nrec == -1){
		fprintf(stderr,"getReport(): read() failed\n");
		return -1;
	} else if(nrec != sizeof(*report)){
		fprintf(stderr,"getReport(): read() failed to fill report (only got %d/%ld)\n",nrec,sizeof(*report));
		return -1;
	}

	return 1;
}

int report(int sock, struct Report report){
	// fprintf(stderr,"report.idnumV is %d\n",report.idnumV);
	// fprintf(stderr,"report.idnumP is %d\n",report.idnumP);
	// fprintf(stderr,"report.vMax.dir is %c\n",report.vMax.dir);
	// fprintf(stderr,"report.vMax.val is %f\n",report.vMax.val);
	// fprintf(stderr,"report.pMax.dir is %c\n",report.pMax.dir);
	// fprintf(stderr,"report.pMax.val is %f\n",report.pMax.val);
	int nsent = write(sock,&report,sizeof(report));
	if(nsent == -1){
		fprintf(stderr,"report(): write() failed\n");
		return 1;
	} else if(nsent != sizeof(report)){
		fprintf(stderr,"report(): write() failed to send report\n");
		return 1;
	} else {
		return 0;
	}
}

int sendQuad(int sock, int idnum, char *triplet){
	// printf("sendCmd(): sending %c%c%c\n",triplet[0],triplet[1],triplet[2]);
	char quad[4] = {(char)idnum,triplet[0],triplet[1],triplet[2]};
	int nsent = write(sock,quad,4);
	if(nsent == -1){
		fprintf(stderr,"sendQuad(): write() failed\n");
		return 1;
	} else if(nsent != 4){
		fprintf(stderr,"sendQuad(): write() failed to send full quad\n");
		return 1;
	} else {
		return 0;
	}
	// fprintf(stderr,"Just wrote: ");
	// if(write(STDERR_FILENO,triplet,3) == -1){
	// 	fprintf(stderr,"sendTriplet(): write() failed\n");
	// 	return 1;
	// }
	// fprintf(stderr," to socket %d\n",sock);
	// return 0;
}

int sendQuad2(int sock, char *quad){
	// printf("sendCmd(): sending %c%c%c\n",triplet[0],triplet[1],triplet[2]);
	// char quad[4] = {(char)idnum,triplet[0],triplet[1],triplet[2]};
	int nsent = write(sock,quad,4);
	if(nsent == -1){
		fprintf(stderr,"sendQuad(): write() failed\n");
		return 1;
	} else if(nsent != 4){
		fprintf(stderr,"sendQuad(): write() failed to send full quad\n");
		return 1;
	} else {
		return 0;
	}
	// fprintf(stderr,"Just wrote: ");
	// if(write(STDERR_FILENO,triplet,3) == -1){
	// 	fprintf(stderr,"sendTriplet(): write() failed\n");
	// 	return 1;
	// }
	// fprintf(stderr," to socket %d\n",sock);
	// return 0;
}

int sendTriplet(int sock, char *triplet){
	// printf("sendCmd(): sending %c%c%c\n",triplet[0],triplet[1],triplet[2]);
	int nsent = write(sock,triplet,3);
	if(nsent == -1){
		fprintf(stderr,"sendTriplet(): write() failed\n");
		return 1;
	} else if(nsent != 3){
		fprintf(stderr,"sendTriplet(): write() failed to send full triplet\n");
		return 1;
	} else {
		return 0;
	}
	// fprintf(stderr,"Just wrote: ");
	// if(write(STDERR_FILENO,triplet,3) == -1){
	// 	fprintf(stderr,"sendTriplet(): write() failed\n");
	// 	return 1;
	// }
	// fprintf(stderr," to socket %d\n",sock);
	// return 0;
}

// int closeComms(int sock){
// 	if(close(sock)){
// 		fprintf(stderr,"closeComms(): close() failed\n");
// 		// return 1;
// 	}
// 	// } else {
// 	// 	fprintf(stdout,"closeComms(): successfully closed\n");
// 	// }
// 	return 0;
// }

int pathPush(struct Path *path, struct Line *linePtr){
	path->nodes = realloc(path->nodes,sizeof(*path->nodes) * ++path->len);
	path->nodes[path->len - 1] = linePtr;
	return 0;
}

int savePath(struct Path *path, struct Paths *pathset){
	pathset->paths = realloc(pathset->paths,sizeof(*pathset->paths) * ++pathset->count);
	pathcpy(&pathset->paths[pathset->count - 1],path);
	return 0;
}

int pathPop(struct Path *path){
	path->nodes = realloc(path->nodes,sizeof(*path->nodes) * --path->len);
	return 0;
}

int printPath(FILE *stream, struct Path path){
	int i;
	for(i = 0; i < path.len - 1; i++){
		fprintf(stream,"%d,",path.nodes[i]->idnum);
	}
	fprintf(stream,"%d\n",path.nodes[i]->idnum);
	return 0;
}

int freePaths(struct Paths pathset){
	for(int i = 0; i < pathset.count; i++){
		free(pathset.paths[i].nodes);
	}
	free(pathset.paths);
	return 0;
}

int printPaths(FILE *stream, struct Paths allpaths){
	for(int i = 0; i < allpaths.count; i++){
		printPath(stream, allpaths.paths[i]);
	}
	return 0;
}

int pathcpy(struct Path *dest, struct Path *src){
	dest->len = src->len;
	dest->nodes = malloc(sizeof(*dest->nodes) * src->len);
	for(int i = 0; i < src->len; i++){
		dest->nodes[i] = src->nodes[i];
	}
	return 0;
}

int parseLinks(struct Links *links, char *line){
	// printf("Parsing: %s\n",line);
	if(line == NULL){
		fprintf(stderr,"parseLinks(): line is NULL\n");
		return 1;
	}
	// int nlinks = argc/4 - 1;
	// int startid[nlinks];
	// char startdir[nlinks];
	// int endid[nlinks];
	// char enddir[nlinks];
	// for(int i = 0; i < nlinks; i++){
	// 	startid[i] = atoi(argv[4 + 4*i]);
	// 	startdir[i] = argv[4 + 4*i + 1][0];
	// 	endid[i] = atoi(argv[4 + 4*i + 2]);
	// 	enddir[i] = argv[4 + 4*i + 3][0];
	// }
	links->nlinks = 0;
	links->linkset = NULL;
	char *ptr = line;
	while(ptr[0] != '\0'){
		links->linkset = realloc(links->linkset,sizeof(*links->linkset) * (links->nlinks + 1));
		links->linkset[links->nlinks].startid = (int)strtol(ptr,&ptr,10);
		// printf("setting startid[%d] to %d\n",links->nlinks,links->linkset[links->nlinks].startid);
		links->linkset[links->nlinks].startdir = ptr[1];
		// printf("setting startdir[%d] to %c\n",links->nlinks,links->linkset[links->nlinks].startdir);
		links->linkset[links->nlinks].endid = (int)strtol(ptr+3,&ptr,10);
		// printf("setting endid[%d] to %d\n",links->nlinks,links->linkset[links->nlinks].endid);
		links->linkset[links->nlinks].enddir = ptr[1];
		// printf("setting enddir[%d] to %c\n",links->nlinks,links->linkset[links->nlinks].enddir);
		links->nlinks++;
		ptr += 3;
	}
	return 0;
}

int broadcast(struct Host *hosts, char *quad){
	struct Host *currhostPtr = hosts;
	while(currhostPtr){
		if(sendQuad2(currhostPtr->sock,quad)){
			fprintf(stderr,"broadcast(): sendQuad2() failed for %s\n",currhostPtr->addr);
			return 1;
		}
		currhostPtr = currhostPtr->next;
	}
	return 0;
}

int bestNearby(struct Line *spikePtr, int ntrials, struct Endpoint *endptPtr){
	/* get score of spikePtr and initialize *endptPtr */
	struct Data data;
	if(getUnitData(spikePtr,'-',ntrials,&data)){
		fprintf(stderr,"bestNearby(): getData() failed\n");
		return 1;
	}
	endptPtr->line = spikePtr;
	endptPtr->data = data;
	struct Line *nearNeighbor, *farNeighbor;
	for(int i = 0; i < spikePtr->neighbors.count; i++){
		nearNeighbor = spikePtr->neighbors.lines[i];
		/* if not already queried, get score of nearNeighbor; if best so far, retain */
		if(!nearNeighbor->queried){
			nearNeighbor->queried = true;
			if(getUnitData(nearNeighbor,'-',ntrials,&data)){
				fprintf(stderr,"bestNearby(): getData() failed\n");
				return 1;
			}
			if(data.val > endptPtr->data.val){
				endptPtr->line = nearNeighbor;
				endptPtr->data = data;
			}
		}
		for(int j = 0; j < nearNeighbor->neighbors.count; j++){
			farNeighbor = nearNeighbor->neighbors.lines[i];
			/* if not already queried, get score of farNeighbor; if best so far, retain */
			if(!farNeighbor->queried){
				farNeighbor->queried = true;
				if(getUnitData(farNeighbor,'-',ntrials,&data)){
					fprintf(stderr,"bestNearby(): getData() failed\n");
					return 1;
				}
				if(data.val > endptPtr->data.val){
					endptPtr->line = farNeighbor;
					endptPtr->data = data;
				}
			}
		}
	}

	/* Reset queried indicators */
	for(int i = 0; i < spikePtr->neighbors.count; i++){
		nearNeighbor = spikePtr->neighbors.lines[i];
		nearNeighbor->queried = false;
		for(int j = 0; j < nearNeighbor->neighbors.count; j++){
			farNeighbor = nearNeighbor->neighbors.lines[i];
			farNeighbor->queried = false;
		}
	}

	return 0;
}

int getUnitData(struct Line *linePtr, char dir, int ntrials, struct Data *dataPtr){
	char quad[4];
	setQuad(quad,(char)linePtr->idnum,dir,(char)ntrials,'f');
	if(sendQuad2(linePtr->host->sock,quad)){
		fprintf(stderr,"broadcast(): sendQuad2() failed for %s\n",linePtr->host->addr);
		return 1;
	}
	int stat = readAnswer(linePtr->host->sock,...);
	if(!stat){
		fprintf(stderr,"getUnitData(): readAnswer() failed to read from %s\n",linePtr->host->addr);
		return 1;
	} else if(stat == -1){
		fprintf(stderr,"getUnitData(): readAnswer() failed for %s\n",linePtr->host->addr);
		return 1;
	}
	dataPtr->val = ...;
	dataPtr->dir = ...;
	return 0;
}

int readAnswer(int sock, ...){
	int nrec = read(sock,...,sizeof(...));
	if(!nrec){
		return 0;
	} else if(nrec == -1){
		fprintf(stderr,"readAnswer(): read() failed\n");
		return -1;
	} else if(nrec != sizeof(...)){
		fprintf(stderr,"readAnswer(): read() failed to fill ... (only got %d/%ld)\n",nrec,sizeof(...));
		return -1;
	}

	return 1;
}

int waitAlert(struct Topdata topdata, int *spikeIDptr, struct timeval *alertTimeout){
	fd_set sockSet;
	FD_ZERO(&sockSet);
	for(int i = 0; i < topdata.nhosts; i++){
		FD_SET(topdata.hostSocks[i],&sockSet);
	}
	int stat = select(topdata.maxHostSock + 1,&sockSet,NULL,NULL,alertTimeout);
	if(!stat){
		fprintf(stderr,"waitAlert(): alertTimeout expired\n");
		return -1;
	} else if(stat == -1){
		perror("waitAlert(){select()}");
		return -1;
	}

	int sock;
	for(int i = 0; i < topdata.nhosts; i++){
		if(FD_ISSET(topdata.hostSocks[i],&sockSet)){
			sock = topdata.hostSocks[i];
			// FD_ZERO(&sockSet);
			break;
		}
	}

	int nrec = read(sock,...,sizeof(...));
	if(!nrec){
		return 0;
	} else if(nrec == -1){
		fprintf(stderr,"waitAlert(): read() failed\n");
		return -1;
	} else if(nrec != sizeof(...)){
		fprintf(stderr,"waitAlert(): read() failed to fill ... (only got %d/%ld)\n",nrec,sizeof(...));
		return -1;
	}

	*spikeIDptr = ...;

	return 1;
}

int getUpdates(struct Endpoint endpt, float frac, char pathAnt, int redundancy){
	/* Request continuous updates */
	char quad[4];
	setQuad(quad,endpt.line->idnum,endpt.data.dir,pathAnt,'r');
	if(sendQuad2(endpt.line->sock,quad)){
		fprintf(stderr,"getUpdates(): sendQuad2() failed for %s\n",endpt.line->ipaddr);
		return 1;
	}

	int stat, nlow = 0;
	while(1){
		stat = readAnswer(endpt.line->sock,...);
		if(!stat){
			fprintf(stderr,"getUpdates(): readAnswer() failed to read from %s\n",endpt.line->ipaddr);
			return 1;
		} else if(stat == -1){
			fprintf(stderr,"getUpdates(): readAnswer() failed for %s\n",endpt.line->ipaddr);
			return 1;
		}

		if(... < endpt.data.val){
			if(++nlow == redundancy){
				break;
			}
		} else {
			nlow = 0;
		}
	}

	/* Halt updates */
	setQuad(quad,endpt.line->idnum,'-','-','h');
	if(sendQuad2(endpt.line->sock,quad)){
		fprintf(stderr,"getUpdates(): sendQuad2() failed for %s\n",endpt.line->ipaddr);
		return 1;
	}
	
	return 0;
}

// int openHosts(struct Hosts hosts, int port, float timeout){
// 	for(int i = 0; i < hosts.count; i++){
// 		if((hosts.array[i].sock = openComms(hosts.array[i].addr,port,timeout)) == -1){
// 			fprintf(stderr,"openHosts(): openComms() failed for %s\n",hosts.array[i].addr);
// 			return 1;
// 		}
// 	}
// 	return 0;
// }

// int closeHosts(struct Hosts hosts){
// 	for(int i = 0; i < hosts.count; i++){
// 		if(closeComms(hosts.array[i].sock)){
// 			fprintf(stderr,"closeHosts(): closeComms() failed for %s\n",hosts.array[i].addr);
// 			return 1;
// 		}
// 	}
// 	return 0;
// }
